--- linux-2.6.9/arch/i386/kernel/process.c.fxsave	2006-05-09 14:03:25.000000000 -0400
+++ linux-2.6.9/arch/i386/kernel/process.c	2006-05-09 14:06:43.000000000 -0400
@@ -578,7 +578,6 @@ struct task_struct fastcall * __switch_t
 
 	/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */
 
-	__unlazy_fpu(prev_p);
 	if (next_p->mm)
 		load_user_cs_desc(cpu, next_p->mm);
 
@@ -625,6 +624,12 @@ struct task_struct fastcall * __switch_t
 	load_TLS(next, cpu);
 
 	/*
+	 * Must be after reload for AMD workaround
+	 */
+
+	__unlazy_fpu(prev_p);
+
+	/*
 	 * Save away %fs and %gs. No need to save %es and %ds, as
 	 * those are always kernel segments while inside the kernel.
 	 */
--- linux-2.6.9/arch/x86_64/kernel/process.c.fxsave	2006-05-09 14:03:25.000000000 -0400
+++ linux-2.6.9/arch/x86_64/kernel/process.c	2006-05-09 14:06:43.000000000 -0400
@@ -428,8 +428,6 @@ struct task_struct *__switch_to(struct t
 	int cpu = smp_processor_id();  
 	struct tss_struct *tss = &per_cpu(init_tss, cpu);
 
-	unlazy_fpu(prev_p);
-
 	/*
 	 * Reload esp0, LDT and the page table pointer:
 	 */
@@ -450,6 +448,12 @@ struct task_struct *__switch_to(struct t
 	load_TLS(next, cpu);
 
 	/* 
+	 * Must be after DS reload for AMD workaround. 
+	 */
+
+	unlazy_fpu(prev_p);
+
+	/* 
 	 * Switch FS and GS.
 	 */
 	{ 
--- linux-2.6.9/include/asm-i386/i387.h.fxsave	2006-05-09 14:03:25.000000000 -0400
+++ linux-2.6.9/include/asm-i386/i387.h	2006-05-09 14:38:52.000000000 -0400
@@ -34,8 +34,12 @@ extern void kernel_fpu_begin(void);
 static inline void __save_init_fpu( struct task_struct *tsk )
 {
 	if ( cpu_has_fxsr ) {
-		asm volatile( "fxsave %0 ; fnclex"
+		asm volatile( "fxsave %0"
 			      : "=m" (tsk->thread.i387.fxsave) );
+		if (tsk->thread.i387.fxsave.swd & (1<<7))
+			asm volatile("fnclex");
+		/* AMD CPUs leak F?P.  Clear it here */
+		asm volatile("ffree %%st(7) ; fildl %0" :: "m" (tsk->flags));
 	} else {
 		asm volatile( "fnsave %0 ; fwait"
 			      : "=m" (tsk->thread.i387.fsave) );
--- linux-2.6.9/include/asm-x86_64/i387.h.fxsave	2004-10-18 17:54:08.000000000 -0400
+++ linux-2.6.9/include/asm-x86_64/i387.h	2006-05-09 14:06:43.000000000 -0400
@@ -143,8 +143,12 @@ static inline void kernel_fpu_end(void)
 
 static inline void save_init_fpu( struct task_struct *tsk )
 {
-	asm volatile( "rex64 ; fxsave %0 ; fnclex"
+	asm volatile( "rex64 ; fxsave %0"
 		      : "=m" (tsk->thread.i387.fxsave));
+	if (tsk->thread.i387.fxsave.swd & (1<<7))
+		asm volatile("fnclex");
+	/* AMD CPUs can leak F?P through FXSAVE.  Clear it here */
+	asm volatile("ffree %%st(7) ; fildl %0" :: "m" (tsk->flags));
 	tsk->thread_info->status &= ~TS_USEDFPU;
 	stts();
 }
