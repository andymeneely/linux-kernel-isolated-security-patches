--- linux-2.6.9/fs/binfmt_elf.c.orig
+++ linux-2.6.9/fs/binfmt_elf.c
@@ -81,7 +81,7 @@ static struct linux_binfmt elf_format = 
 		.min_coredump	= ELF_EXEC_PAGESIZE
 };
 
-#define BAD_ADDR(x)	((unsigned long)(x) > TASK_SIZE)
+#define BAD_ADDR(x)	((unsigned long)(x) >= TASK_SIZE)
 
 static int set_brk(unsigned long start, unsigned long end)
 {
@@ -409,7 +409,7 @@ static unsigned long load_elf_interp(str
 	     * <= p_memsize so it is only necessary to check p_memsz.
 	     */
 	    k = load_addr + eppnt->p_vaddr;
-	    if (k > TASK_SIZE || eppnt->p_filesz > eppnt->p_memsz ||
+	    if (BAD_ADDR(k) || eppnt->p_filesz > eppnt->p_memsz ||
 		eppnt->p_memsz > TASK_SIZE || TASK_SIZE - eppnt->p_memsz < k) {
 	        error = -ENOMEM;
 		goto out_close;
@@ -885,7 +885,7 @@ static int load_elf_binary(struct linux_
 		 * allowed task size. Note that p_filesz must always be
 		 * <= p_memsz so it is only necessary to check p_memsz.
 		 */
-		if (k > TASK_SIZE || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||
+		if (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||
 		    elf_ppnt->p_memsz > TASK_SIZE ||
 		    TASK_SIZE - elf_ppnt->p_memsz < k) {
 			/* set_brk can never work.  Avoid overflows.  */
@@ -936,9 +936,9 @@ static int load_elf_binary(struct linux_
 						    &interp_load_addr,
 						    load_bias);
 		if (BAD_ADDR(elf_entry)) {
-			printk(KERN_ERR "Unable to load interpreter\n");
-			send_sig(SIGSEGV, current, 0);
-			retval = -ENOEXEC; /* Nobody gets to see this, but.. */
+			force_sig(SIGSEGV, current);
+			retval = IS_ERR((void *)elf_entry) ?
+					(int)elf_entry : -EINVAL;
 			goto out_free_dentry;
 		}
 		reloc_func_desc = interp_load_addr;
@@ -948,6 +948,11 @@ static int load_elf_binary(struct linux_
 		kfree(elf_interpreter);
 	} else {
 		elf_entry = loc->elf_ex.e_entry;
+		if (BAD_ADDR(elf_entry)) {
+			force_sig(SIGSEGV, current);
+			retval = -EINVAL;
+			goto out_free_dentry;
+		}
 	}
 
 	kfree(elf_phdata);
--- linux-2.6.9/arch/x86_64/kernel/signal.c.orig
+++ linux-2.6.9/arch/x86_64/kernel/signal.c
@@ -29,7 +29,8 @@
 #include <asm/uaccess.h>
 #include <asm/i387.h>
 #include <asm/proto.h>
 #include <asm/ia32_unistd.h>
+#include <asm/vsyscall.h>
 
 /* #define DEBUG_SIG 1 */
 
@@ -99,8 +100,12 @@ restore_sigcontext(struct pt_regs *regs,
 
 #define COPY(x)		err |= __get_user(regs->x, &sc->x)
 
-	COPY(rdi); COPY(rsi); COPY(rbp); COPY(rsp); COPY(rbx);
-	COPY(rdx); COPY(rcx); COPY(rip);
+	COPY(rdi); COPY(rsi); COPY(rbp); COPY(rsp);
+	if (unlikely(regs->rsp >= TASK_SIZE))
+		regs->rsp = 0UL;
+	COPY(rbx); COPY(rdx); COPY(rcx); COPY(rip);
+	if (unlikely(regs->rip >= TASK_SIZE && regs->rip < VSYSCALL_START))
+		regs->rip = 0UL;
 	COPY(r8);
 	COPY(r9);
 	COPY(r10);
@@ -325,9 +330,11 @@ static void setup_rt_frame(int sig, stru
 	   next argument after the signal number on the stack. */
 	regs->rsi = (unsigned long)&frame->info; 
 	regs->rdx = (unsigned long)&frame->uc; 
-	regs->rip = (unsigned long) ka->sa.sa_handler;
-
 	regs->rsp = (unsigned long)frame;
+	if (unlikely((unsigned long)ka->sa.sa_handler >= TASK_SIZE))
+		regs->rip = 0UL;
+	else
+		regs->rip = (unsigned long)ka->sa.sa_handler;
 
 	set_fs(USER_DS);
 	if (regs->eflags & TF_MASK) {
--- linux-2.6.9/fs/binfmt_elf.c.orig
+++ linux-2.6.9/fs/binfmt_elf.c
@@ -705,7 +705,9 @@ static int load_elf_binary(struct linux_
 
 	relocexec = 0;
 
-	if (current->personality == PER_LINUX)
+	if (current->personality == PER_LINUX ||
+	    bprm->e_uid != current->euid ||
+	    bprm->e_gid != current->egid)
 	switch (exec_shield) {
 	case 1:
 		if (executable_stack == EXSTACK_DISABLE_X) {
