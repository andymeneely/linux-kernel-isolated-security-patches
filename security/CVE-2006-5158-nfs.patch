--- linux-2.6.9/fs/nfs/inode.c.org
+++ linux-2.6.9/fs/nfs/inode.c
@@ -696,14 +698,11 @@ static int nfs_show_stats(struct seq_fil
 /*
  * Invalidate the local caches
  */
-void
-nfs_zap_caches(struct inode *inode)
+void nfs_zap_caches_locked(struct inode *inode)
 {
 	struct nfs_inode *nfsi = NFS_I(inode);
 	int mode = inode->i_mode;
 
-	spin_lock(&inode->i_lock);
-
 	nfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);
 
 	NFS_ATTRTIMEO(inode) = NFS_MINATTRTIMEO(inode);
@@ -714,7 +713,12 @@ nfs_zap_caches(struct inode *inode)
 		nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;
 	else
 		nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;
+}
 
+void nfs_zap_caches(struct inode *inode)
+{
+	spin_lock(&inode->i_lock);
+	nfs_zap_caches_locked(inode);
 	spin_unlock(&inode->i_lock);
 }
 
@@ -740,7 +744,7 @@ nfs_invalidate_inode(struct inode *inode
 
 	make_bad_inode(inode);
 	inode->i_mode = save_mode;
-	nfs_zap_caches(inode);
+	nfs_zap_caches_locked(inode);
 }
 
 struct nfs_find_desc {
--- a/fs/lockd/clntlock.c
+++ b/fs/lockd/clntlock.c
@@ -150,6 +150,8 @@ void nlmclnt_mark_reclaim(struct nlm_host *host)
 	list_for_each(tmp, &file_lock_list) {
 		fl = list_entry(tmp, struct file_lock, fl_link);
 
+		if (!(fl->fl_flags & FL_POSIX))
+			continue;
 		inode = fl->fl_file->f_dentry->d_inode;
 		if (inode->i_sb->s_magic != NFS_SUPER_MAGIC)
 			continue;
@@ -219,6 +221,8 @@ restart:
 	list_for_each(tmp, &file_lock_list) {
 		fl = list_entry(tmp, struct file_lock, fl_link);
 
+		if (!(fl->fl_flags & FL_POSIX))
+			continue;
 		inode = fl->fl_file->f_dentry->d_inode;
 		if (inode->i_sb->s_magic != NFS_SUPER_MAGIC)
 			continue;
--- linux-2.6.9/fs/lockd/clntproc.c.org
+++ linux-2.6.9/fs/lockd/clntproc.c
@@ -287,7 +287,7 @@ nlmclnt_alloc_call(void)
 {
 	struct nlm_rqst	*call;
 
-	while (!signalled()) {
+	for (;;) {
 		call = (struct nlm_rqst *) kmalloc(sizeof(struct nlm_rqst), GFP_KERNEL);
 		if (call) {
 			memset(call, 0, sizeof(*call));
@@ -295,6 +295,8 @@ nlmclnt_alloc_call(void)
 			locks_init_lock(&call->a_res.lock.fl);
 			return call;
 		}
+		if (signalled())
+			break;
 		printk("nlmclnt_alloc_call: failed, waiting for memory\n");
 		current->state = TASK_INTERRUPTIBLE;
 		schedule_timeout(5*HZ);
@@ -639,12 +641,13 @@ nlmclnt_unlock(struct nlm_rqst *req, str
 	 * reclaimed while we're stuck in the unlock call. */
 	fl->fl_u.nfs_fl.flags &= ~NFS_LCK_GRANTED;
 
+	posix_lock_file_wait(fl->fl_file, fl);
+
 	if (req->a_flags & RPC_TASK_ASYNC) {
 		status = nlmclnt_async_call(req, NLMPROC_UNLOCK,
 					nlmclnt_unlock_callback);
 		/* Hrmf... Do the unlock early since locks_remove_posix()
 		 * really expects us to free the lock synchronously */
-		posix_lock_file(fl->fl_file, fl);
 		if (status < 0) {
 			nlmclnt_release_lockargs(req);
 			kfree(req);
@@ -657,7 +660,6 @@ nlmclnt_unlock(struct nlm_rqst *req, str
 	if (status < 0)
 		return status;
 
-	posix_lock_file(fl->fl_file, fl);
 	if (resp->status == NLM_LCK_GRANTED)
 		return 0;
 